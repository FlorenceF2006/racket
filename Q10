#lang racket
;;Fee Chen, Florence Fan
;;question is why I need stack and how do I implement stack?
;;first attempt: using lists as stacks for each function application


;;add a global const to data in compile-simpl
;;(const NULL 0)

;;need a global map that contains the name of all functions, and their argument name.
(define dict-fun empty)
(define (lookup dict fun)
  (cond[(empty? dict) (error "undefined function")]
       [(equal? (first (first dict)) fun) (first dict)]
       [else (lookup (rest dict) fun)]))



(define (return-addr nm)
  (string->symbol (string-append "_RETURN_ADDR_" (symbol->string nm))))
(define (return-val nm)
  (string->symbol (string-append "_RETURN_VALUE_" (symbol->string nm))))
(define (arg arg-nm fun-nm)
  (string->symbol (string-append "_ARG_" (symbol->string fun-nm) "_" (symbol->string arg-nm))))
(define (var var-nm fun-nm)
  (string->symbol (string-append "_VAR_" (symbol->string fun-nm) "_" (symbol->string var-nm))))
(define (op-trans op)
  (match op
    ['+ 'add]
    ['* 'mul]
    ['- 'sub]
    ['div 'div]
    ['mod 'mod]
    ['= 'equal]
    ['> 'gt]
    ['< 'lt]
    ['>= 'ge]
    ['<= 'le]
    ['not 'lnot]
    ['and 'land]
    ['or 'lor]
    ))


;;every thing should be rewritten
;;(listof functions -> listof instruction)
;;(fun (id ,,) (vars[] stmt))
(define (compile-simpl program)
  ;;function -> listof instruction
  (define (compile-fun function)

    ;;three helper functions are just here to add instructions
    (define data empty)
    (define inst empty)
    (define (add-data lst)
      (set! data (append data (list lst))))
    (define (add-inst lst)
      (set! inst (append inst (list lst))))
    ;;two fixed parameters can be immediately read in
    (define args (rest (second function)))
    (define fun-nm (first (second function)))
    (define fun-inst (rest (rest (third function))))
    ;;define a counter for our function temp vars
    (define ctr 0)
    (define (get-sym num)
      (var (string->symbol (number->string num))))
    (define (incr-ctr n)
      (set! ctr (+ ctr n)))
    ;; think about this: what is the difference between vars[()],fun(),
    ;;what is the difference between the datas held by them.
    ;;vars[()] hold local const. why? because this has to be initiate every
    ;;separate function application.
    ;;but argument can change depending on what you pass to them.
    ;;modification or mutation to data in vars will not survive to the next time you call them.
    ;;so if we want a list-based stack for data, don't do it to vars, do it to arguments.

    ;;step1: "constify" all the values in var
    (define (constify lst)
      (cond[(empty? lst) empty]
           [(match (first lst)
              [`(,nm,val)
               (cons (list 'const (var nm) val))])]))
    ;;initially, data store all the constified const
    (set! data (constify (second (third function))))
    ;;then for every application: we want empty stack for every arg,return-val,return-addr
    ;;therefore, let us initialize the stack(implemented in list) here when defining the function.
    (define (init-stk lst)
      (cond[(empty? lst) empty]
           [(match (first lst)
              [`nm
               (cons (list 'data (arg nm) 'NULL) (init-stk (rest lst)))])]))
    (add-data (init-stk args))
    (define return-value (return-val nm))
    (define return-address (return-addr nm))
    (add-data (list 'data return-value 'NULL))
    (add-data (list 'data return-address 'NULL))
    ;;those datas are loaded before the function top label, which means function will
    ;;only initiated those data once. In fact, all the data in "data" is initiated only once
    ;;the problem I'm encountering right now is that (1) we don't know the name of argument stack
    ;;(2) we need a function that gives us the top of such stack, and retrieve to previous one after
    ;;using the top.
    ;;
    ;;aexp -> pys
    (define (eval-aexp exp)
      (define (load-arg val-lst arg-lst)
        (cond[(empty? val-lst) void]
             [else
              (define xi (arg (first arg-lst)))
              (define vi (first val-lst))
              (add-inst (list 'move 


              
      (match exp
        [`(op,exp1,exp2)
         (set! op (op-trans op))
         (set! exp1 (eval-aexp exp1))
         (set! exp2 (eval-aexp exp2))
         (define pys (get-sym  ctr))
         (incr-ctr 1)
         (add-inst (list op pys exp1 exp2))
         (add-data (list 'data pys 0))
         pys]
        [`(,id ...)
         (define psy (get-sym ctr))
         (incr-ctr 1)
         (
         
         
    
    
    
    
    
    

     
)
  )

       
       
       
  


























             
       
       



















             
       
       
