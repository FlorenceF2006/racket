#lang racket
;;Fee Chen, Florence Fan
;;question is why I need stack and how do I implement stack?
;;first attempt: using lists as stacks for each function application


(struct fn-toekn (name argnum))

;;add a global const to data in compile-simpl
;;(const NULL 0)

;;need a global map that contains the name of all functions, and their argument name.
(define dict-fun empty)
(define (lookup dict fun)
  (cond[(empty? dict) (error "undefined function")]
       [(equal? (first (first dict)) fun) (first dict)]
       [else (lookup (rest dict) fun)]))



(define (return-addr nm)
  (string->symbol (string-append "_RETURN_ADDR_" (symbol->string nm))))
(define (return-val nm)
  (string->symbol (string-append "_RETURN_VALUE_" (symbol->string nm))))
(define (arg arg-nm fun-nm)
  (string->symbol (string-append "_ARG_" (symbol->string fun-nm) "_" (symbol->string arg-nm))))
(define (var var-nm fun-nm)
  (string->symbol (string-append "_VAR_" (symbol->string fun-nm) "_" (symbol->string var-nm))))
(define (op-trans op)
  (match op
    ['+ 'add]
    ['* 'mul]
    ['- 'sub]
    ['div 'div]
    ['mod 'mod]
    ['= 'equal]
    ['> 'gt]
    ['< 'lt]
    ['>= 'ge]
    ['<= 'le]
    ['not 'lnot]
    ['and 'land]
    ['or 'lor]
    ))


;;every thing should be rewritten
;;(listof functions -> listof instruction)
;;(fun (id ,,) (vars[] stmt))
(define (compile-simpl program)
  ;; this instruction needed to be added to the front of A-PRIMPL program so that it
  ;; jump to eval main function first
  (define fst-inst '((jump main)))

  (define args (rest (second function)))
  (define fun-nm (first (second function)))
  (define fun-arg# (- (length (second function)) 1))
  ;;fn-name-fetch: (listof fun) -> (listof fn-token)
  (define (fn-fetch program)
    (define (fn-fetch-h program acc)
      (if (empty? program)
          acc
          (fn-fetch-h (rest progarm)
                      (cons (fn-token (fun-nm (first program))
                                      (fun-arg# (first program)))
                            acc))))
    (fn-fetch-h program empty))

  ;; funlist creates a table to check if the is defined in the given SIMPL
  (define funlist (fn-fetch program))

  ;;function -> listof instruction
  (define (compile-fun function)
    ;;three helper functions are just here to add instructions
    (define data empty)
    (define inst empty)
    (define (add-data lst)
      (set! data (append data (list lst))))
    (define (add-inst lst)
      (set! inst (append inst (list lst))))

    (define fun-inst (rest (rest (third function))))
    ;;define a counter for our function temp vars
    (define ctr 0)
    (define (get-sym num)
      (var (string->symbol (number->string num)) fun-nm))
    (define (incr-ctr n)
      (set! ctr (+ ctr n)))
    
    (define (init-stk lst)
      (cond[(empty? lst) void]
           [(match (first lst)
              [`nm
               (add-data (list 'data (arg nm fun-nm) 'NULL))
               (init-stk (rest lst))])]))
    
    (define return-value (return-val fun-nm))
    (define return-address (return-addr fun-nm))
    (add-data (list 'data return-value 'NULL))
    (add-data (list 'data return-address 'NULL)))

  ;; compile-simpl-h: final job
  (define (compile-simpl-h program acc)
    (if (empty? program)
        (append fst-inst acc)
        (compile-simpl-h (rest program)
                         (append acc (compile-fun (first program))))))
  
  (compile-simple-h program empty)
  )

       
       
       
  


























             
       
       



















             
       
       
