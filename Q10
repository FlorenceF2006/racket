#lang racket
;;Fee Chen, Florence Fan
;;question is why I need stack and how do I implement stack?
;;first attempt: using lists as stacks for each function application


;;add a global const to data in compile-simpl
;;(const NULL 0)

;;need a global map that contains the name of all functions, and their argument name.
(define dict-fun empty)
(define (lookup dict fun)
  (cond[(empty? dict) (error "undefined function")]
       [(equal? (first (first dict)) fun) (first dict)]
       [else (lookup (rest dict) fun)]))



(define (return-addr nm)
  (string->symbol (string-append "_RETURN_ADDR_" (symbol->string nm))))
(define (return-val nm)
  (string->symbol (string-append "_RETURN_VALUE_" (symbol->string nm))))
(define (arg arg-nm fun-nm)
  (string->symbol (string-append "_ARG_" (symbol->string fun-nm) "_" (symbol->string arg-nm))))
(define (var var-nm fun-nm)
  (string->symbol (string-append "_VAR_" (symbol->string fun-nm) "_" (symbol->string var-nm))))
(define (op-trans op)
  (match op
    ['+ 'add]
    ['* 'mul]
    ['- 'sub]
    ['div 'div]
    ['mod 'mod]
    ['= 'equal]
    ['> 'gt]
    ['< 'lt]
    ['>= 'ge]
    ['<= 'le]
    ['not 'lnot]
    ['and 'land]
    ['or 'lor]
    ))


;;every thing should be rewritten
;;(listof functions -> listof instruction)
;;(fun (id ,,) (vars[] stmt))
(define (compile-simpl program)
  ;;function -> listof instruction
  (define (compile-fun function)

    ;;three helper functions are just here to add instructions
    (define data empty)
    (define inst empty)
    (define (add-data lst)
      (set! data (append data (list lst))))
    (define (add-inst lst)
      (set! inst (append inst (list lst))))
    ;;two fixed parameters can be immediately read in
    (define args (rest (second function)))
    (define fun-nm (first (second function)))
    (define fun-inst (rest (rest (third function))))
    ;;define a counter for our function temp vars
    (define ctr 0)
    (define (get-sym num)
      (var (string->symbol (number->string num)) fun-nm))
    (define (incr-ctr n)
      (set! ctr (+ ctr n)))
    
    (define (init-stk lst)
      (cond[(empty? lst) void]
           [(match (first lst)
              [`nm
               (add-data (list 'data (arg nm fun-nm) 'NULL))
               (init-stk (rest lst))])]))
    
    (define return-value (return-val fun-nm))
    (define return-address (return-addr fun-nm))
    (add-data (list 'data return-value 'NULL))
    (add-data (list 'data return-address 'NULL))
    
    
         
         
    
    
    
    
    
    

     
)
  )

       
       
       
  


























             
       
       



















             
       
       
