#lang racket
;;Fee Chen, Florence Fan
;;question is why I need stack and how do I implement stack?
;;first attempt: using lists as stacks for each function application




;;add a global const to data in compile-simpl
;;(const NULL 0)
(struct fn-token (id tkn-arg tkn-var))
;;need a global map that contains the name of all functions, and their argument name.
(define dict-fun empty)
(define (lookup dict fun)
  (cond[(empty? dict) (error "undefined function")]
       [(equal? (fn-token-id (first dict)) fun) (first dict)]
       [else (lookup (rest dict) fun)]))



(define (return-addr nm)
  (string->symbol (string-append "_RETURN_ADDR_" (symbol->string nm))))
(define (return-val nm)
  (string->symbol (string-append "_RETURN_VALUE_" (symbol->string nm))))
(define (arg arg-nm fun-nm)
  (string->symbol (string-append "_ARG_" (symbol->string fun-nm) "_" (symbol->string arg-nm))))
(define (var var-nm fun-nm)
  (string->symbol (string-append "_VAR_" (symbol->string fun-nm) "_" (symbol->string var-nm))))
(define (op-trans op)
  (match op
    ['+ 'add]
    ['* 'mul]
    ['- 'sub]
    ['div 'div]
    ['mod 'mod]
    ['= 'equal]
    ['> 'gt]
    ['< 'lt]
    ['>= 'ge]
    ['<= 'le]
    ['not 'lnot]
    ['and 'land]
    ['or 'lor]
    ))


;;every thing should be rewritten
;;(listof functions -> listof instruction)
;;(fun (id ,,) (vars[] stmt))
(define (compile-simpl program)
  ;; this instruction needed to be added to the front of A-PRIMPL program so that it
  ;; jump to eval main function first
  (define fst-inst '((jump main)))
  
  ;;(define (args function) (rest (second function)))
  ;;(define (fun-nm function) (first (second function)))
  ;;(define (fun-arg# function) (- (length (second function)) 1))
  ;;fn-name-fetch: (listof fun) -> (listof fn-token)
  ;;(fun (id id ..) (vars [(id int) ...] stmt ...))
  (define (fn-fetch prog)
    (define (fn-fetch-h prog acc)
      (cond[(empty? prog) acc]
           [else
            (define fun (first prog))
            (define fun-nm (first (second fun)))
            (define fun-args (rest (second fun)))
            (define var-args (map first (second (third fun))))
            (define var-val (map second (second (third fun))))
            (fn-fetch-h (rest prog) (cons (fm-token fun-nm (append fun-args var-args) var-val) acc))]          
          
           ))
    (fn-fetch-h prog empty))

  ;; funlist creates a table to check if the is defined in the given SIMPL
  (define funlist (fn-fetch program))

  ;;function -> listof instruction
  (define (compile-fun function)
    ;;three helper functions are just here to add instructions
    (define data empty)
    (define inst empty)
    (define (add-data lst)
      (set! data (append data (list lst))))
    (define (add-inst lst)
      (set! inst (append inst (list lst))))

    (define fun-inst (rest (rest (third function))))
    (define name (first function))
    ;;define a counter for our function temp vars
    (define ctr 0)
    (define (get-sym num)
      (var (string->symbol (number->string num)) fun-nm))
    (define (incr-ctr n)
      (set! ctr (+ ctr n)))
    ;;add arg and var into data list
    (define (init-arg lst)
      (cond[(empty? lst) void]
           [else (add-data (list 'data (first lst) 'NULL))
                 (init-arg (rest lst))
                 ]))
    (define (init-var var-nm var-val)
      (cond[(empty? lst) void]
           [else (add-data (list 'data (first lst) (first var-val)))
                 (init-var (rest var-nm) (rest var-val))]))
    
    
    
    
    (define return-value (return-val fun-nm))
    (define return-address (return-addr fun-nm))
    (add-data (list 'data return-value 'NULL))
    (add-data (list 'data return-address 'NULL))
    (define (eval-aexp aexp)
      (define (load-args fun-args args-val id)
        (cond[(empty? fun-args) void]
             [else
              (add-inst (list 'add fp fp 1))
              (add-inst (list 'move (list stack fp) (arg (first fun-args) id)))
              (define new_arg (eval-aexp-h (first args-val)))
              (add-inst (list 'move (arg (first fun-args) id) new_arg))
              (load-args (rest fun-args) (rest args-val) id)
              ]))
      (define (unload-args fun-args id)
        (add-inst (list 'move (return-addr id) (list stack fp)))
        (add-inst (list 'sub fp fp 1))
        (cond[(empty? fun-args) void]
             [else
              (add-inst (list 'move (arg (first fun-args) id) (list stack fp)))
              (add-inst (list 'sub fp fp 1))
              (unload-args (rest fun-args) id)
              ]))
        
                                                                     
      (define (eval-aexp-h aexp)
        (match aexp
          [`(,op,aexp1,aexp2)
           (set! aexp1 (eval-aexp-h aexp1))
           (set! aexp2 (eval-aexp-h aexp2))
           (set! op (op-trans op))
           (define pys (get-sym ctr))
           (incr-ctr 1)
           (add-data (list 'data pys 'NULL))
           (add-inst (list op pys aexp1 aexp2))
           pys]
          [`(,id ...)
           (define token (lookup dict-fun id))
           (define fun-args (fn-token-tkn-args token))
           (define var-val (fn-token-tkn-var token))
           (define fun-val (append (rest aexp) var-val))
           (if (= (length fun-val) (length fun-args)) void (error "arguments")) 
           (add-inst (list 'add fp fp 1))
           (add-inst (list 'move (list stack fp) (return-addr id)))
           (load-args fun-args fun-val id)
           (add-inst (list 'jsr (return-addr id) (start id)))
           (unload-args fun-args id)
           (define pys (get-sym ctr))
           (incr-ctr 1)
           (add-data (list 'data pys 'NULL))
           (add-inst (list 'move pys (return-val id)))
           pys]
          [`,x (if (number? x) x (arg x fun-nm))
               ])))
    (define (eval-bexp exp)
      ;;eval-h: return a pysymbol
      (define (eval-h lst op sym)
        (cond[(empty? lst) void]
             [else
              (define cur (eval-bexp (first lst)))
              (add-inst (list (op-trans op) sym cur sym) acc)
              (eval-h (rest lst) op sym)]))
      (match exp
        [`(,op ,bexp1 ,bexp2)
         (define val1 (eval-bexp bexp1))
         (define val2 (eval-bexp bexp2))
         (define psy (get-sym ctr))
         (incr-ctr 1)
         (add-inst (list (op-trans op) psy val1 val2) acc)
         (add-inst (list  'data psy #f) mem)
         psy]
        [`(,op,bexp)
         (define val (eval-bexp bexp))
         (define psy (get-sym ctr))
         (incr-ctr 1)
         (add-inst (list (op-trans op) psy val) acc)
         (add-inst (list 'data psy #f) mem) psy]
        ['true #t]
        ['false #f]
        [x (cond[(not (list? x)) x]
                [else (define psy (get-sym ctr))
                      (incr-ctr 1)
                      (if (equal? (first exp) 'and) (add-inst (list 'data psy #t) mem)
                          (add-inst (list 'data psy #f) mem))
                      (eval-h (rest exp) (first exp) psy) psy])])
      )
    (define (compile-fun-h stmt)
      (
    )
  


  ;; compile-simpl-h: final job
  (define (compile-simpl-h program acc)
    (if (empty? program)
        (append fst-inst acc)
        (compile-simpl-h (rest program)
                         (append acc (compile-fun (first program))))))
  
  (compile-simple-h program empty)
  )

       
       
       
  


























             
       
       



















             
       
